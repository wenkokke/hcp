\documentclass[submission,copyright,creativecommons]{eptcs}
\providecommand{\event}{Linearity and TLLA 2018}
\usepackage[fleqn]{amsmath}
\usepackage{amsthm}
\usepackage{nameref,hyperref,cleveref}
\usepackage[inline]{enumitem}
\usepackage{breakurl} % Not needed if you use pdflatex only.
\usepackage{underscore} % Only needed if you use pdflatex.
\usepackage{textcomp,textgreek,upgreek}
\newtheorem{definition}{Definition}
\newtheorem{lemma}{Lemma}
\newtheorem{theorem}{Theorem}
\newtheorem{corollary}{Corollary}
\input{preamble-typing}

\title{Taking Linear Logic Apart}
\author{%
  Wen Kokke
  \institute{University of Edinburgh\\ Edinburgh, Scotland}
  \email{wen.kokke@ed.ac.uk}
  \and
  Marco Peressotti
  \institute{University of Southern Denmark\\ Odense, Denmark}
  \email{peressotti@imada.sdu.dk}
  \and
  Fabrizio Montesi
  \institute{University of Southern Denmark\\ Odense, Denmark}
  \email{fmontesi@imada.sdu.dk}}
\def\titlerunning{Taking Linear Logic Apart}
\def\authorrunning{W.\ Kokke, M.\ Peressotti, and F.\ Montesi}

\begin{document}
\maketitle

\begin{abstract}
\end{abstract}

\section{Classical Processes}

\begin{definition}[Terms]\label{def:cp-terms}
  \[
    \begin{array}{rllrll}
      \tm{P}, \tm{Q}, \tm{R}
           :=& \tm{\cpLink{x}{y}}       &\text{link}
      &  \mid& \tm{\cpCut{x}{P}{Q}}     &\text{parallel composition, ``cut''}
      \\ \mid& \tm{\cpSend{x}{y}{P}{Q}} &\text{``output''}
      &  \mid& \tm{\cpRecv{x}{y}{P}}    &\text{``input''}
      \\ \mid& \tm{\cpHalt{x}}          &\text{halt}
      &  \mid& \tm{\cpWait{x}{P}}       &\text{wait}
      \\ \mid& \tm{\cpInl{x}{P}}        &\text{select left choice}
      &  \mid& \tm{\cpInr{x}{P}}        &\text{select right choice}
      \\ \mid& \tm{\cpCase{x}{P}{Q}}    &\text{offer binary choice}
      &  \mid& \tm{\cpAbsurd{x}}        &\text{offer nullary choice}
    \end{array}
  \]
\end{definition}

\begin{definition}[Structural congruence]\label{def:cp-equiv}
  The structural congruence $\equiv$ is the congruence closure over terms which
  satisfies the following additional axioms:
  \[
    \setlength{\arraycolsep}{3pt}
    \begin{array}{llcll}
      \cpEquivLinkComm
      & \tm{\cpLink{x}{y}}
      & \equiv
      & \tm{\cpLink{y}{x}}
      \\
      \cpEquivCutComm
      & \tm{\cpCut{x}{P}{Q}}
      & \equiv
      & \tm{\cpCut{x}{Q}{P}}
      \\
      \cpEquivCutAss1
      & \tm{\cpCut{x}{P}{\cpCut{y}{Q}{R}}}
      & \equiv
      & \tm{\cpCut{y}{\cpCut{x}{P}{Q}}{R}}
      & \text{if }\notFreeIn{x}{R}\text{ and }\notFreeIn{y}{P}
    \end{array}
  \]
\end{definition}

\begin{definition}[Reduction]\label{def:cp-reduction}
  A reduction $\reducesto{P}{Q}$ denotes that the process $\tm{P}$ can reduce
  to the process $\tm{Q}$ in a single step.
  The relation $\Longrightarrow^\star$ is the reflexive, transitive closure of
  $\Longrightarrow$.
  Reductions can only be constructed as follows:
  \[
    \begin{array}{llcll}
      \cpRedAxCut1
      & \tm{\cpCut{x}{\cpLink{w}{x}}{P}}
      & \Longrightarrow
      & \tm{\cpSub{w}{x}{P}} 
      \\
      \cpRedBetaTensParr
      & \tm{\cpCut{x}{\cpSend{x}{y}{P}{Q}}{\cpRecv{x}{z}{R}}}
      & \Longrightarrow
      & \tm{\cpCut{y}{P}{\cpCut{x}{Q}{\cpSub{y}{z}{R}}}}
      \\
      \cpRedBetaOneBot
      & \tm{\cpCut{x}{\cpHalt{x}}{\cpWait{x}{P}}}
      & \Longrightarrow
      & \tm{P}
      \\
      \cpRedBetaPlusWith1
      & \tm{\cpCut{x}{\cpInl{x}{P}}{\cpCase{x}{Q}{R}}}
      & \Longrightarrow
      & \tm{\cpCut{x}{P}{Q}}
      \\
      \cpRedBetaPlusWith2
      & \tm{\cpCut{x}{\cpInr{x}{P}}{\cpCase{x}{Q}{R}}}
      & \Longrightarrow
      & \tm{\cpCut{x}{P}{R}}
      \\
      \cpRedKappaTens1
      & \tm{\cpCut{x}{\cpSend{y}{z}{P}{Q}}{R}}
      & \Longrightarrow \;
      & \tm{\cpSend{y}{z}{\cpCut{x}{P}{R}}{Q}}
        \quad \text{if} \; \notFreeIn{x}{Q}
      \\
      \cpRedKappaTens2
      & \tm{\cpCut{x}{\cpSend{y}{z}{P}{Q}}{R}}
      & \Longrightarrow \;
      & \tm{\cpSend{y}{z}{P}{\cpCut{x}{Q}{R}}}
        \quad \text{if} \; \notFreeIn{x}{P}
      \\
      \cpRedKappaParr
      & \tm{\cpCut{x}{\cpRecv{y}{z}{P}}{R}}
      & \Longrightarrow \;
      & \tm{\cpRecv{y}{z}{\cpCut{x}{P}{R}}}
      \\
      \cpRedKappaBot
      & \tm{\cpCut{x}{\cpWait{y}{P}}{R}}
      & \Longrightarrow \;
      & \tm{\cpWait{y}{\cpCut{x}{P}{R}}}
      \\
      \cpRedKappaPlus1
      & \tm{\cpCut{x}{\cpInl{y}{P}}{R}}
      & \Longrightarrow \;
      & \tm{\cpInl{y}{\cpCut{x}{P}{R}}}
      \\
      \cpRedKappaPlus2
      &\tm{\cpCut{x}{\cpInr{y}{P}}{R}}
      & \Longrightarrow \;
      & \tm{\cpInr{y}{\cpCut{x}{P}{R}}}
      \\
      \cpRedKappaWith
      & \tm{\cpCut{x}{\cpCase{y}{P}{Q}}{R}}
      & \Longrightarrow \;
      & \tm{\cpCase{y}{\cpCut{x}{P}{R}}{\cpCut{x}{Q}{R}}}
      \\
      \cpRedKappaTop
      & \tm{\cpCut{x}{\cpAbsurd{y}}{R}}
      & \Longrightarrow \;
      & \tm{\cpAbsurd{y}}
    \end{array}
  \]
  \begin{center}
    \begin{prooftree*}
      \AXC{$\reducesto{P}{P^\prime}$}
      \SYM{\cpRedGammaCut}
      \UIC{$\reducesto{\cpCut{x}{P}{Q}}{\cpCut{x}{P^\prime}{Q}}$}
    \end{prooftree*}
    \begin{prooftree*}
      \AXC{$\tm{P}\equiv\tm{Q}$}
      \AXC{$\reducesto{Q}{Q^\prime}$}
      \AXC{$\tm{Q^\prime}\equiv\tm{P^\prime}$}
      \SYM{\cpRedGammaEquiv}
      \TIC{$\reducesto{P}{P^\prime}$}
    \end{prooftree*}
  \end{center}
\end{definition}

\begin{definition}[Types]\label{def:cp-types}
  \[
    \begin{array}{rclrcl}
      \ty{A}, \ty{B}, \ty{C}
           :=& \ty{A \tens B} &\text{pair of independent processes}
      &  \mid& \ty{\one}      &\text{unit for} \; {\tens}
      \\ \mid& \ty{A \parr B} &\text{pair of interdependent processes}
      &  \mid& \ty{\bot}      &\text{unit for} \; {\parr}
      \\ \mid& \ty{A \plus B} &\text{internal choice}
      &  \mid& \ty{\nil}      &\text{unit for} \; {\plus}
      \\ \mid& \ty{A \with B} &\text{external choice}
      &  \mid& \ty{\top}      &\text{unit for} \; {\with}
    \end{array}
  \]
\end{definition}

\begin{figure*}[!htb]
  Structural Rules.
  \begin{center} \cpInfAx     \cpInfCut      \end{center}

  Logical Rules.
  \begin{center} \cpInfTens   \cpInfParr     \end{center}
  \begin{center} \cpInfOne    \cpInfBot      \end{center}
  \begin{center} \cpInfPlus1  \cpInfPlus2    \end{center}
  \begin{center} \cpInfWith                  \end{center}
  \begin{center} \cpInfNil    \cpInfTop      \end{center}

  \caption{Classical Processes (\cp)}
  \label{fig:cp}
\end{figure*}

\begin{lemma}[Preservation for $\equiv$]\label{lem:cp-preservation-equiv}
  If $\tm{P}\equiv\tm{Q}$, then $\seq[P]{\Gamma}$ iff $\seq[Q]{\Gamma}$.
\end{lemma}
\begin{proof}
  By induction on the derivation of $\tm{P}\equiv\tm{Q}$.
\end{proof}

\begin{theorem}[Preservation]\label{thm:cp-preservation}
  If $\seq[P]{\Gamma}$ and $\reducesto{P}{Q}$, then $\seq[Q]{\Gamma}$.
\end{theorem}
\begin{proof}
  By induction on the derivation of $\reducesto{P}{Q}$.
\end{proof}

\begin{theorem}[Progress]\label{thm:cp-progress}
  If $\seq[P]{\Gamma}$, then there exists a $\tm{Q}$ such that
  $\tm{P}\Longrightarrow^\star\tm{Q}$ and $\tm{Q}$ is not a cut.
\end{theorem}
\begin{proof}
  By induction on the derivation of $\seq[P]{\Gamma}$.
  If the last rule is \textsc{Cut}, there are four cases:
  \begin{enumerate*}[label={\alph*)}]
  \item
    if either side of the cut is an axiom, we apply \cpRedAxCut1;
  \item
    if either side of the cut is itself a cut, we recursively eliminate the cut;
  \item
    if both sides are logical rules acting on the cut formula, we apply
    one of the $\beta$-rules;
  \item
    otherwise, at least one side is a logical rule acting on a formula other
    than the cut formula, in which case we apply one of the $\kappa$-rules.
  \end{enumerate*}
\end{proof}


\section{Hypersequent Classical Processes}

\begin{definition}[Terms]\label{def:hcp-terms}
  \[
    \begin{array}{rllrll}
      \tm{P}, \tm{Q}, \tm{R}
           :=& \tm{\cpLink{x}{y}}         &\text{link}
      &  \mid& \tm{\piHalt}               &\text{terminated process}
      \\ \mid& \tm{\piNew{x}{P}}          &\text{name restriction, ``cut''}
      &  \mid& \tm{( \piPar{P}{Q} )}      &\text{parallel composition, ``mix''}
      \\ \mid& \tm{\piBoundSend{x}{y}{P}} &\text{``output''}
      &  \mid& \tm{\piRecv{x}{y}{P}}      &\text{``input''}
      \\ \mid& \tm{\piBoundSend{x}{}{P}}  &\text{``halt''}
      &  \mid& \tm{\cpWait{x}{}{P}}       &\text{wait}
      \\ \mid& \tm{\cpInl{x}{P}}          &\text{select left choice}
      &  \mid& \tm{\cpInr{x}{P}}          &\text{select right choice}
      \\ \mid& \tm{\cpCase{x}{P}{Q}}      &\text{offer binary choice}
      &  \mid& \tm{\cpAbsurd{x}}          &\text{offer nullary choice}
    \end{array}
  \]
\end{definition}

\begin{definition}[Structural congruence]\label{def:hcp-equiv}
  The structural congruence $\equiv$ is the congruence closure over terms which
  satisfies the following additional axioms:
  \[
    \setlength{\arraycolsep}{3pt}
    \begin{array}{llcllllcll}
        \cpEquivLinkComm
      & \tm{\cpLink{x}{y}}
      & \equiv
      & \tm{\cpLink{y}{x}}
      &
      &
        \hccpEquivMixHalt1
      & \tm{\piPar{P}{\piHalt}}
      & \equiv
      & \tm{P}
      &
      \\
        \hccpEquivMixComm
      & \tm{\piPar{P}{Q}}
      & \equiv
      & \tm{\piPar{Q}{P}}
      &
      &
        \hccpEquivMixAss1
      & \tm{\piPar{P}{( \piPar{Q}{R} )}}
      & \equiv
      & \tm{\piPar{( \piPar{P}{Q} )}{R}}
      &
      \\
        \hccpEquivNewComm
      & \tm{\piNew{x}{\piNew{y}{P}}}
      & \equiv
      & \tm{\piNew{y}{\piNew{x}{P}}}
      &
      &
        \hccpEquivScopeExt1
      & \tm{\piNew{x}{( \piPar{P}{Q} )}}
      & \equiv
      & \tm{\piPar{P}{\piNew{x}{Q}}}
      & \text{if }\notFreeIn{x}{P} 
    \end{array}
  \]
\end{definition}

\begin{definition}[Reduction]\label{def:hcp-reduction}
  A reduction $\reducesto{P}{Q}$ denotes that the process $\tm{P}$ can reduce
  to the process $\tm{Q}$ in a single step.
  The relation $\Longrightarrow^\star$ is the reflexive, transitive closure of
  $\Longrightarrow$.
  Reductions can only be constructed as follows:
  \[
    \begin{array}{llcll}
      \hccpRedAxCut1
      & \tm{\cpCut{x}{\cpLink{w}{x}}{P}}
      & \Longrightarrow
      & \tm{\cpSub{w}{x}{P}} 
      \\
      \hccpRedBetaTensParr
      & \tm{\cpCut{x}{\piBoundSend{x}{y}{P}}{\piRecv{x}{z}{R}}}
      & \Longrightarrow
      & \tm{\piNew{x}{\piNew{y}{(\piPar{P}{\cpSub{y}{z}{R}})}}}
      \\
      \hccpRedBetaOneBot
      & \tm{\cpCut{x}{\piBoundSend{x}{}{P}}{\piRecv{x}{}{P}}}
      & \Longrightarrow
      & \tm{\piPar{P}{Q}}
      \\
      \hccpRedBetaPlusWith1
      & \tm{\cpCut{x}{\cpInl{x}{P}}{\cpCase{x}{Q}{R}}}
      & \Longrightarrow
      & \tm{\cpCut{x}{P}{Q}}
      \\
      \hccpRedBetaPlusWith2
      & \tm{\cpCut{x}{\cpInr{x}{P}}{\cpCase{x}{Q}{R}}}
      & \Longrightarrow
      & \tm{\cpCut{x}{P}{R}}
      \\
      \hccpRedKappaNuTens
      & \tm{\piNew{x}{\piBoundSend{y}{z}{P}}}
      & \Longrightarrow
      & \tm{\piBoundSend{y}{z}{\piNew{x}{P}}}
      \\
      \hccpRedKappaNuParr
      & \tm{\piNew{x}{\piRecv{y}{z}{P}}}
      & \Longrightarrow
      & \tm{\piRecv{y}{z}{\piNew{x}{P}}}
      \\
      \hccpRedKappaNuOne
      & \tm{\piNew{x}{\piBoundSend{y}{}{P}}}
      & \Longrightarrow
      & \tm{\piBoundSend{y}{}{\piNew{x}{P}}}
      \\
      \hccpRedKappaNuBot
      & \tm{\piNew{x}{\piRecv{y}{}{P}}}
      & \Longrightarrow
      & \tm{\piRecv{y}{}{\piNew{x}{P}}}
      \\
      \hccpRedKappaNuPlus1
      & \tm{\piNew{x}{\cpInl{y}{P}}}
      & \Longrightarrow
      & \tm{\cpInl{y}{\piNew{x}{P}}}
      \\
      \hccpRedKappaNuPlus2
      & \tm{\piNew{x}{\cpInr{y}{P}}}
      & \Longrightarrow
      & \tm{\cpInr{y}{\piNew{x}{P}}}
      \\
      \hccpRedKappaNuWith
      & \tm{\piNew{x}{\cpCase{y}{P}{Q}}}
      & \Longrightarrow
      & \tm{\cpCase{y}{\piNew{x}{P}}{\piNew{x}{Q}}}
      \\
      \hccpRedKappaNuTop
      & \tm{\piNew{x}{\cpAbsurd{y}}}
      & \Longrightarrow
      & \tm{\cpAbsurd{y}}
      \\
      \hccpRedKappaMixTens
      & \tm{(\piPar{\piBoundSend{y}{z}{P}}{R})}
      & \Longrightarrow
      & \tm{\piBoundSend{y}{z}{(\piPar{P}{R})}}
      \\
      \hccpRedKappaMixParr
      & \tm{(\piPar{\piRecv{y}{z}{P}}{R})}
      & \Longrightarrow
      & \tm{\piRecv{y}{z}{(\piPar{P}{R})}}
      \\
      \hccpRedKappaMixOne
      & \tm{(\piPar{\piBoundSend{y}{}{P}}{R})}
      & \Longrightarrow
      & \tm{\piBoundSend{y}{}{(\piPar{P}{R})}}
      \\
      \hccpRedKappaMixBot
      & \tm{(\piPar{\piRecv{y}{}{P}}{R})}
      & \Longrightarrow
      & \tm{\piRecv{y}{}{(\piPar{P}{R})}}
      \\
      \hccpRedKappaMixPlus1
      & \tm{(\piPar{\cpInl{y}{P}}{R})}
      & \Longrightarrow
      & \tm{\cpInl{y}{(\piPar{P}{R})}}
      \\
      \hccpRedKappaMixPlus2
      & \tm{(\piPar{\cpInr{y}{P}}{R})}
      & \Longrightarrow
      & \tm{\cpInr{y}{(\piPar{P}{R})}}
      \\
      \hccpRedKappaMixWith
      & \tm{(\piPar{\cpCase{y}{P}{Q}}{R})}
      & \Longrightarrow
      & \tm{\cpCase{y}{(\piPar{P}{R})}{(\piPar{Q}{R})}}
      \\
      \hccpRedKappaMixTop
      & \tm{(\piPar{\cpAbsurd{y}}{R})}
      & \Longrightarrow
      & \tm{\cpAbsurd{y}}
    \end{array}
  \]
  \begin{center}
    \begin{prooftree*}
      \AXC{$\reducesto{P}{P^\prime}$}
      \SYM{\hccpRedGammaNew}
      \UIC{$\reducesto{\piNew{x}{P}}{\piNew{x}{P^\prime}}$}
    \end{prooftree*}
    \begin{prooftree*}
      \AXC{$\reducesto{P}{P^\prime}$}
      \SYM{\hccpRedGammaMix}
      \UIC{$\reducesto{\piPar{P}{Q}}{\piPar{P^\prime}{Q}}$}
    \end{prooftree*}
    \begin{prooftree*}
      \AXC{$\tm{P}\equiv\tm{Q}$}
      \AXC{$\reducesto{Q}{Q^\prime}$}
      \AXC{$\tm{Q^\prime}\equiv\tm{P^\prime}$}
      \SYM{\hccpRedGammaEquiv}
      \TIC{$\reducesto{P}{P^\prime}$}
    \end{prooftree*}
  \end{center}
\end{definition}

\begin{figure*}[!htb]
  Structural Rules.
  \begin{center} \hccpInfAx        \hccpInfCycle \end{center}
  \begin{center} \hccpInfMix       \hccpInfHalt  \end{center}

  Logical Rules.
  \begin{center} \hccpInfBoundTens \hccpInfParr  \end{center}
  \begin{center} \hccpInfOne       \hccpInfBot   \end{center}
  \begin{center} \hccpInfPlus1     \hccpInfPlus2 \end{center}
  \begin{center} \hccpInfWith                    \end{center}
  \begin{center} \hccpInfNil       \hccpInfTop   \end{center}

  \centering
  (Where each logical rule has the side condition that $\tm{x} \not\in
  \ty{\mathcal{G}}$.)

  \caption{Hypersequent Classical Processes (\hcp)}
  \label{fig:hccp}
\end{figure*}

\begin{lemma}[Preservation for $\equiv$]\label{lem:hcp-preservation-equiv}
  If $\tm{P}\equiv\tm{Q}$, then $\seq[P]{\mathcal{G}}$ iff $\seq[Q]{\Gamma}$.
\end{lemma}
\begin{proof}
  By induction on the derivation of $\tm{P}\equiv\tm{Q}$.
\end{proof}

\begin{theorem}[Preservation]\label{thm:hcp-preservation}
  If $\seq[P]{\mathcal{G}}$ and $\reducesto{P}{Q}$, then $\seq[Q]{\Gamma}$.
\end{theorem}
\begin{proof}
  By induction on the derivation of $\reducesto{P}{Q}$.
\end{proof}

\begin{theorem}[Progress]\label{thm:hcp-progress}
  If $\seq[P]{\mathcal{G}}$, then there exists a $\tm{Q}$ such that
  $\tm{P}\Longrightarrow^\star\tm{Q}$ and $\tm{Q}$ is not a cut or a mix.
\end{theorem}
\begin{proof}
  By induction on the derivation of $\seq[P]{\mathcal{G}}$.
  If the last rule is a cut, there are three cases:
  \begin{enumerate*}[label={\alph*)}]
  \item
    if the rule under the cut is the corresponding mix, we eliminate both as in
    \cref{thm:cp-progress};
  \item
    if the rule under the cut is an unrelated mix, we rewrite by
    \hccpEquivScopeExt{}, and recursively eliminate the cut; 
  \item
    if the rule under the cut is a logical rule, we apply one of the
    $\kappa\nu$-rules.
  \end{enumerate*}
  If the last rule is mix, there are two cases:
  \begin{enumerate*}[label={\alph*)}]
  \item
    if the rule under the mix is a cut or another mix, we recursively eliminate it;
  \item
    if the rule under the mix is a logical rule, we apply one of the
    $\kappa{\ppar}$-rules. 
  \end{enumerate*}
\end{proof}

\section{Relation between \cp and \hcp}

We define a translation from terms in \cp to terms in \hcp which breaks down the term constructs in \cp into their more atomic constructs in \hcp:
\begin{definition}\label{def:cp2hcp-terms}
  \[
    \begin{array}{lcllcl}
         \tm{\mtf{\cpLink{x}{y}}}
      &  := & \tm{\cpLink{x}{y}}
      &  \tm{\mtf{\cpCut{x}{P}{Q}}}
      &  := & \tm{\piNew{x}{(\piPar{\mtf{P}}{\mtf{Q}})}}
      \\ \tm{\mtf{\cpSend{x}{y}{P}{Q}}}
      &  := & \tm{\piBoundSend{x}{y}{(\piPar{\mtf{P}}{\mtf{Q}})}}
      &  \tm{\mtf{\cpRecv{x}{y}{P}}}
      &  := & \tm{\piRecv{x}{y}{\mtf{P}}}
      \\ \tm{\mtf{\cpHalt{x}}}
      &  := & \tm{\piBoundSend{x}{}{\piHalt}}
      &  \tm{\mtf{\cpWait{x}{P}}}
      &  := & \tm{\piRecv{x}{}{\mtf{P}}}
      \\ \tm{\mtf{\cpInl{x}{P}}}
      &  := & \tm{\cpInl{x}{\mtf{P}}}
      &  \tm{\mtf{\cpInr{x}{P}}}
      &  := & \tm{\cpInr{x}{\mtf{P}}}
      \\ \tm{\mtf{\cpCase{x}{P}{Q}}}
      &  := & \tm{\cpCase{x}{\mtf{P}}{\mtf{Q}}}
      &  \tm{\mtf{\cpAbsurd{x}}}
      &  := & \tm{\cpAbsurd{x}}
    \end{array}
  \]
\end{definition}

\begin{theorem}\label{thm:cp2hcp-typing}
  If $\seq[P]{\Gamma}$ in \cp, then $\seq[\mtf{P}]{\Gamma}$ in \hcp.
\end{theorem}
\begin{proof}
  By induction on the derivation of $\seq[P]{\Gamma}$.
    \begin{itemize}
  \item 
    Case \textsc{Cut}. We rewrite to:
    \begin{gather*}
      \begin{array}{lcl}
        \AXC{$\seq[P]{\Gamma, \tmty{x}{A}}$}
        \AXC{$\seq[Q]{\Delta, \tmty{x}{A^\bot}}$}
        \NOM{Cut}
        \BIC{$\seq[\cpCut{x}{P}{Q}]{\Gamma, \Delta}$}
        \DisplayProof
        & \Rightarrow
        & \AXC{$\seq[\mtf{P}]{\Gamma, \tmty{x}{A}}$}
          \AXC{$\seq[\mtf{Q}]{\Delta, \tmty{x}{A^\bot}}$}
          \NOM{H-Mix} 
          \BIC{$\seq[\piPar{\mtf{P}}{\mtf{Q}}]{
          \Gamma, \tmty{x}{A} \hsep \Delta, \tmty{x}{A^\bot}}$}
          \NOM{H-Cut}
          \UIC{$\seq[\piNew{x}{(\piPar{\mtf{P}}{\mtf{Q}})}]{
          \Gamma, \Delta}$}
          \DisplayProof
      \end{array}
    \end{gather*}
  \item
    Case $(\tens)$. We rewrite as follows:
    \begin{gather*}
      \begin{array}{lcl}
        \AXC{$\seq[P]{\Gamma, \tmty{y}{A}}$}
        \AXC{$\seq[Q]{\Delta, \tmty{x}{B}}$}
        \SYM{\tens}
        \BIC{$\seq[\cpSend{x}{y}{P}{Q}]{\Gamma, \Delta, \tmty{x}{A \tens B}}$}
        \DisplayProof
        & \Rightarrow
        & \AXC{$\seq[\mtf{P}]{\Gamma, \tmty{y}{A}}$}
          \AXC{$\seq[\mtf{Q}]{\Delta, \tmty{x}{B}}$}
          \NOM{H-Mix}
          \BIC{$\seq[\piPar{\mtf{P}}{\mtf{Q}}]{
          \Gamma, \tmty{y}{A} \hsep \Delta, \tmty{x}{B}}$}
          \SYM{\tens}
          \UIC{$\seq[\piBoundSend{x}{y}{(\piPar{\mtf{P}}{\mtf{Q}})}]{
          \Gamma, \Delta, \tmty{x}{A \tens B}}$}
          \DisplayProof
      \end{array}
    \end{gather*}
  \item
    Case $(\one)$. We rewrite as follows:
    \begin{flalign*}
      \begin{array}{lcl}
        \AXC{}\SYM{\one}
        \UIC{$\seq[\cpHalt{x}]{\tmty{x}{\one}}$}
        \DisplayProof
        & \Rightarrow
        & \AXC{}
          \NOM{H-Halt}
          \UIC{$\seq[\piHalt]{\emptyhypercontext}$}
          \SYM{\one}
          \UIC{$\seq[\piBoundSend{x}{}{\piHalt}]{\tmty{x}{\one}}$}
          \DisplayProof
      \end{array}      
    \end{flalign*}
  \end{itemize}
  The other cases are trivial.
\end{proof}

\begin{theorem}\label{thm:cp2hcp-equiv}
  $\tm{P}\equiv\tm{Q}$ in \cp iff $\tm{\mtf{P}}\equiv\tm{\mtf{Q}}$ in \hcp.
\end{theorem}
\begin{proof}
  By induction on the derivation of $\tm{P}\equiv\tm{Q}$.
% \begin{itemize}
% \item
%   Case \cpEquivCutComm.
%   \begin{gather*}
%   \begin{array}{lcl}
%     \tm{\piNew{x}{(\piPar{\mtf{P}}{\mtf{Q}})}}
%     & \equiv & \text{by \hccpEquivMixComm}
%     \\
%     \tm{\piNew{x}{(\piPar{\mtf{Q}}{\mtf{P}})}}
%   \end{array}
%   \end{gather*}
% \item
%   Case \cpEquivCutAss1.
%   \begin{gather*}
%   \begin{array}{lcl}
%     \tm{\piNew{x}{(\piPar{\mtf{P}}{\piNew{y}{(\piPar{\mtf{Q}}{\mtf{R}})}})}}
%     & \equiv & \text{%
%                by \hccpEquivNewComm, \hccpEquivMixAss1, \hccpEquivMixComm,
%                and \hccpEquivScopeExt{}}
%     \\
%     \tm{\piNew{y}{(\piPar{\piNew{x}{(\piPar{\mtf{P}}{\mtf{Q}})}}{\mtf{R}})}}
%   \end{array}
%   \end{gather*}
% \end{itemize}
% The other cases are trivial.
\end{proof}

\begin{theorem}\label{thm:cp2hcp-reduction}
  If $\reducesto{P}{Q}$ in \cp, then $\reducesto{\mtf{P}}{\mtf{Q}}$ in \hcp.
\end{theorem}
\begin{proof}
  By induction on the the derivation of $\reducesto{P}{Q}$.
% \begin{itemize}
% \item
%   Case \cpRedBetaTensParr.
%   \begin{gather*}
%   \begin{array}{lcl}
%     \tm{\piNew{x}{(\piPar{\piBoundSend{x}{y}{(\piPar{P}{Q})}}{\piRecv{x}{z}{R}})}}
%     & \Longrightarrow & \text{by \hccpRedBetaTensParr}
%     \\
%     \tm{\piNew{x}{\piNew{y}{(\piPar{(\piPar{P}{Q})}{\cpSub{y}{z}{R}})}}}
%     & \equiv & \text{%
%                by \hccpEquivNewComm, \hccpEquivMixAss1, and \hccpEquivScopeExt1}
%     \\
%     \tm{\piNew{y}{(\piPar{P}{\piNew{x}{(\piPar{Q}{\cpSub{y}{z}{R}})}})}}
%   \end{array}
%   \end{gather*}
% \item
%   Case \cpRedBetaOneBot.
%   \begin{gather*}
%   \begin{array}{lcl}
%     \tm{\piNew{x}{(\piPar{\piBoundSend{x}{}{\piHalt}}{\piRecv{x}{}{\mtf{Q}}})}}
%     & \Longrightarrow & \text{by \hccpRedBetaOneBot}
%     \\
%     \tm{(\piPar{\piHalt}{\mtf{Q}})}
%     & \equiv & \text{by \hccpEquivMixHalt1}
%     \\
%     \tm{\mtf{Q}}
%   \end{array}
%   \end{gather*}
% \end{itemize}
% The other cases are trivial.
\end{proof}

\begin{theorem}\label{hcp2cp-reduction}
  If $\reducesto{\mtf{P}}{R}$ in \hcp, then there is a $\tm{Q}$ such that
  $\reducesto{P}{Q}$ in \cp and $\tm{R}\Longrightarrow^\star\tm{\mtf{Q}}$ in \hcp.
\end{theorem}
\begin{proof}
  By induction on the derivation of $\reducesto{\mtf{P}}{R}$.
  The cases for \hccpRedAxCut1 and the $\beta$-rules are trivial.
  For the $\kappa\nu$-rules, we rewrite by the appropriate $\kappa{\ppar}$ rule,
  and vice versa.
\end{proof}

\begin{definition}\label{def:hcp-gk}
  The relation $\tm{P}\equiv_{\gamma\kappa}\tm{Q}$ is the congruence closure of
  the $\gamma$- and $\kappa$-rules for \hcp (\cref{def:hcp-reduction}).
\end{definition}

\begin{lemma}[Disentangle]\label{lem:hcp-disentangle}
  If $\seq[P]{\Gamma_1 \hsep \dots \hsep \Gamma_n}$ in \hcp,
  then there exist $\seq[P_1]{\Gamma_1}, \dots, \seq[P_n]{\Gamma_n}$ in \cp,
  such that
  $\tm{P}\equiv_{\gamma\kappa}\tm{(\mtf{P_1}\ppar\dots\ppar\mtf{P_n})}$.
\end{lemma}
\begin{proof}  
  We repeatedly apply the $\kappa{\ppar}$-rules to move the mixes upwards.
  There are three cases:
  \begin{enumerate*}[label={\alph*)}]
  \item
    if a mix gets stuck under a cut, it forms a \cp cut;
  \item
    if a mix gets stuck under a $(\tens)$, it forms a \cp $(\tens)$;
  \item
    otherwise, it moves all the way to the top.
  \end{enumerate*}
  Since the only way to continue after a $(\one)$ is by using a mix, all
  applications of $(\one)$ are now followed by an application of
  \textsc{H-Halt}, forming a \cp $(\one)$.
\end{proof}

We can interpret environments as types by collapsing them using a series of
pars.
\begin{definition}\label{def:bigparr}
  \begin{gather*}
  \begin{array}{lcl}
    \ty{\bigparr(\tmty{x_1}{A_1} , \dots , \tmty{x_n}{A_n})}
    & = & \ty{A_1 \parr \dots \parr A_n}
  \end{array}
  \end{gather*}
\end{definition}

\begin{lemma}\label{lem:cp-bigparr}
  If $\seq{\Gamma}$ in \cp, then $\seq{\bigparr\Gamma}$ in \cp.
\end{lemma}
\begin{proof}
  By induction on the structure of the environment $\Gamma$.
  \begin{itemize}
  \item
    If $\ty{\Gamma} = \ty{A}$, then the statement is trivially true.
  \item
    If $\ty{\Gamma} = \ty{A, B, \Gamma'}$,
    then we apply $(\parr)$ to get $\seq{A \parr B, \Gamma'}$,\\
    and apply the induction hypothesis.
  \end{itemize}
\end{proof}

We can interpret hyper-environments as types by collapsing them using a series
of tensors. In the case of the empty hyper-environment
$\ty{\emptyhypercontext}$, we interpret this as the unit of tensor.
\begin{definition}\label{def:bigtens}
  \begin{gather*}
  \begin{array}{lcl}
    \ty{\bigtens(\emptyhypercontext)}
    & = & \ty{\one}
    \\
    \ty{\bigtens(\Gamma_1 \hsep \dots \hsep \Gamma_n)}
    & = & \ty{\bigparr\Gamma_1 \tens \dots \tens \bigparr\Gamma_n}
  \end{array}
  \end{gather*}
\end{definition}

\begin{theorem}\label{thm:hcp2cp-bigtens}
  If $\seq{\mathcal{G}}$ in \hcp, then $\seq{\bigtens\mathcal{G}}$ in \cp.
\end{theorem}
\begin{proof}
  By case analysis on the structure of the hyper-environment $\ty{\mathcal{G}}$.
  \begin{itemize}
  \item
    If $\ty{\mathcal{G}} = \ty{\emptyhypercontext}$, we apply $(\one)$.
  \item
    If $\ty{\mathcal{G}} = \ty{\Gamma_1 \hsep \dots \hsep \Gamma_n}$,
    we apply \cref{lem:hcp-disentangle} to obtain proofs of $\seq{\Gamma_1}, \dots,
    \seq{\Gamma_n}$ in \cp, then we apply \cref{lem:cp-bigparr} to each of
    those proofs to obtain proofs of $\seq{\bigparr\Gamma_1}, \dots,
    \seq{\bigparr\Gamma_n}$, and join them using $(\tens)$ to obtain a single
    proof of $\seq{\bigtens\mathcal{G}}$ in \cp.
  \end{itemize}
\end{proof}

\bibliographystyle{eptcs}
\bibliography{main}
\end{document}
%%% Local Variables:
%%% TeX-master: "main"
%%% End:
