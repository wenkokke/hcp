\documentclass[draft,submission,copyright,creativecommons]{eptcs}
\providecommand{\event}{Linearity and TLLA 2018}
\usepackage[british]{babel}
\usepackage[all]{foreign}
\usepackage[fleqn]{amsmath}
\usepackage{amsthm}
\usepackage[inline]{enumitem}
\usepackage{breakurl} % Not needed if you use pdflatex only.
\usepackage{underscore} % Only needed if you use pdflatex.
\usepackage{textcomp,textgreek,upgreek}
\usepackage[
	sectionbib,
	square,
	numbers,
	sort&compress
	]{natbib} % \citet
\usepackage{nameref,hyperref,cleveref}
\hypersetup{
	hidelinks,
	final
}
\newtheorem{definition}{Definition}
\newtheorem{lemma}{Lemma}
\newtheorem{theorem}{Theorem}
\newtheorem{corollary}{Corollary}
\input{preamble-typing}

\usepackage[
%	disable,     % hide all todos
	obeyDraft,   % show todos only in draft mode
%	obeyFinal,   % hide todos if in final mode
	textwidth=3cm,
	textsize=small,
]{todonotes}


\title{Taking Linear Logic Apart}
\author{%
  Wen Kokke
  \institute{University of Edinburgh\\ Edinburgh, Scotland}
  \email{wen.kokke@ed.ac.uk}
  \and
  Fabrizio Montesi
  \institute{University of Southern Denmark\\ Odense, Denmark}
  \email{fmontesi@imada.sdu.dk}
  \and
  Marco Peressotti
  \institute{University of Southern Denmark\\ Odense, Denmark}
  \email{peressotti@imada.sdu.dk}}
\def\titlerunning{Taking Linear Logic Apart}
\def\authorrunning{W.\ Kokke, F.\ Montesi, and M.\ Peressotti}

\begin{document}
\maketitle

\begin{abstract}
We introduce the calculus of Hypersequent Classical Processes (\hcp), which extends the research line on the relationship between linear logic and bridges the gap between the structures of operators used as proof terms in previous work and those of the standard $\pi$-calculus (in particular parallel operator and restriction).
The key twist from previous work is registering parallelism in typing judgements, by generalising linear logic judgements from one sequents to many (hypersequents).
\end{abstract}

\section{Introduction}
\label{sec:introduction}

Classical Processes (CP) \cite{wadler2014} is a process calculus inspired by the correspondence between the session-typed $\pi$-calculus and linear logic \cite{caires2010}, where processes correspond to proofs, session types (communication protocols) to propositions, and communication to cut elimination. Bridging process languages to linear logic paves the way to apply methods developed in one field to the other. This already worked for a few results, in both directions. For example, the proof theory of linear logic can be used to guarantee progress for processes \cite{caires2010,wadler2014}, and multiparty session types, originally developed for processes \cite{honda2016}, inspired a generalisation of the standard cut rule to the composition of an arbitrary number of proofs, allowing for safe circular dependencies among proofs \cite{carbone17}.

The hallmark of CP is that the semantics of processes is given by sound proof transformations in Classical Linear Logic (CLL). While this permits reusing the metatheory of linear logic ``as is'' to reason about process behaviour (\eg, cut elimination yields communication progress), it also exhibits some fundamental discrepancies with the key operators of the $\pi$-calculus \cite{milner1992a,milner1992b}.

Some discrepancies are syntactic. For example, the term for output of a linear name is $\cpSend{x}{y}{P}{Q}$, read ``send $y$ over $x$ and proceed as $P$ in parallel to $Q$''. Notice that the term constructor for output here actually 
takes $x$, $y$, $P$ and $Q$ as parameters at the same time. This discrepancy is caused by adopting processes as proof terms for CLL: the typing rule for 
output (\ie, the $\tens$ rule of CLL) checks that the processes respectively implementing the behaviours of $y$ ($P$) and of $x$ ($Q$) share no resources, by taking two premises ($P$ and $Q$).
In general, there is no independent parallel term $P \mid Q$ in the grammar of CP, and even if we added it as the $\NOM{Mix}$ rule suggested in the original presentation of CP \cite{wadler2014}, it would not allow $P$ and $Q$ to communicate as in standard $\pi$-calculus. Synchronisation is governed instead by the restriction operator $\piNew{x}{(\piPar{P}{Q})}$ (we use the latest syntax for CP, from \cite{carbone2016}), which links $x$ at $P$ with $y$ at $Q$ to enable communication. Again, parallel is mixed with another operator (restriction here), but in this case it means that $P$ and $Q$ will communicate

The discrepancies carry over from syntax (and typing) to semantics.
The rule for reducing an output with an input in CP is the following.
\[
	\cpCut{x}{\cpSend{x}{y}{P}{Q}}{\cpRecv{x}{y}{R}}
  \Longrightarrow
  \cpCut{y}{P}{\cpCut{x}{Q}{R}}
\]
Notice how the rule needs to inspect the structure of the continuation of the output term ($\piPar{P}{Q}$) to produce a typable structure for the resulting network, by nesting restrictions appropriately.

\section{Classical Processes}

\begin{definition}[Terms]\label{def:cp-terms}
  \[
    \begin{array}{rllrll}
      \tm{P}, \tm{Q}, \tm{R}
           :=& \tm{\cpLink{x}{y}}       &\text{link}
      &  \mid& \tm{\cpCut{x}{P}{Q}}     &\text{parallel composition, ``cut''}
      \\ \mid& \tm{\cpSend{x}{y}{P}{Q}} &\text{output}
      &  \mid& \tm{\cpRecv{x}{y}{P}}    &\text{input}
      \\ \mid& \tm{\cpHalt{x}}          &\text{halt}
      &  \mid& \tm{\cpWait{x}{P}}       &\text{wait}
      \\ \mid& \tm{\cpInl{x}{P}}        &\text{select left choice}
      &  \mid& \tm{\cpInr{x}{P}}        &\text{select right choice}
      \\ \mid& \tm{\cpCase{x}{P}{Q}}    &\text{offer binary choice}
      &  \mid& \tm{\cpAbsurd{x}}        &\text{offer nullary choice}
    \end{array}
  \]
\end{definition}

\begin{definition}[Structural congruence]\label{def:cp-equiv}
  The structural congruence $\equiv$ is the congruence closure over terms which
  satisfies the following additional axioms:
  \[
    \setlength{\arraycolsep}{3pt}
    \begin{array}{llcll}
      \cpEquivLinkComm
      & \tm{\cpLink{x}{y}}
      & \equiv
      & \tm{\cpLink{y}{x}}
      \\
      \cpEquivCutComm
      & \tm{\cpCut{x}{P}{Q}}
      & \equiv
      & \tm{\cpCut{x}{Q}{P}}
      \\
      \cpEquivCutAss1
      & \tm{\cpCut{x}{P}{\cpCut{y}{Q}{R}}}
      & \equiv
      & \tm{\cpCut{y}{\cpCut{x}{P}{Q}}{R}}
      & \text{if }\notFreeIn{x}{R}\text{ and }\notFreeIn{y}{P}
    \end{array}
  \]
\end{definition}

\begin{definition}[Reduction]\label{def:cp-reduction}
  A reduction $\reducesto{P}{Q}$ denotes that the process $\tm{P}$ can reduce
  to the process $\tm{Q}$ in a single step.
  The relation $\Longrightarrow^\star$ is the reflexive, transitive closure of
  $\Longrightarrow$.
  Reductions can only be constructed as follows:
  \[
    \begin{array}{llcll}
      \cpRedAxCut1
      & \tm{\cpCut{x}{\cpLink{w}{x}}{P}}
      & \Longrightarrow
      & \tm{\cpSub{w}{x}{P}} 
      \\
      \cpRedBetaTensParr
      & \tm{\cpCut{x}{\cpSend{x}{y}{P}{Q}}{\cpRecv{x}{z}{R}}}
      & \Longrightarrow
      & \tm{\cpCut{y}{P}{\cpCut{x}{Q}{\cpSub{y}{z}{R}}}}
      \\
      \cpRedBetaOneBot
      & \tm{\cpCut{x}{\cpHalt{x}}{\cpWait{x}{P}}}
      & \Longrightarrow
      & \tm{P}
      \\
      \cpRedBetaPlusWith1
      & \tm{\cpCut{x}{\cpInl{x}{P}}{\cpCase{x}{Q}{R}}}
      & \Longrightarrow
      & \tm{\cpCut{x}{P}{Q}}
      \\
      \cpRedBetaPlusWith2
      & \tm{\cpCut{x}{\cpInr{x}{P}}{\cpCase{x}{Q}{R}}}
      & \Longrightarrow
      & \tm{\cpCut{x}{P}{R}}
      \\
      \cpRedKappaTens1
      & \tm{\cpCut{x}{\cpSend{y}{z}{P}{Q}}{R}}
      & \Longrightarrow \;
      & \tm{\cpSend{y}{z}{\cpCut{x}{P}{R}}{Q}}
        \quad \text{if} \; \notFreeIn{x}{Q}
      \\
      \cpRedKappaTens2
      & \tm{\cpCut{x}{\cpSend{y}{z}{P}{Q}}{R}}
      & \Longrightarrow \;
      & \tm{\cpSend{y}{z}{P}{\cpCut{x}{Q}{R}}}
        \quad \text{if} \; \notFreeIn{x}{P}
      \\
      \cpRedKappaParr
      & \tm{\cpCut{x}{\cpRecv{y}{z}{P}}{R}}
      & \Longrightarrow \;
      & \tm{\cpRecv{y}{z}{\cpCut{x}{P}{R}}}
      \\
      \cpRedKappaBot
      & \tm{\cpCut{x}{\cpWait{y}{P}}{R}}
      & \Longrightarrow \;
      & \tm{\cpWait{y}{\cpCut{x}{P}{R}}}
      \\
      \cpRedKappaPlus1
      & \tm{\cpCut{x}{\cpInl{y}{P}}{R}}
      & \Longrightarrow \;
      & \tm{\cpInl{y}{\cpCut{x}{P}{R}}}
      \\
      \cpRedKappaPlus2
      &\tm{\cpCut{x}{\cpInr{y}{P}}{R}}
      & \Longrightarrow \;
      & \tm{\cpInr{y}{\cpCut{x}{P}{R}}}
      \\
      \cpRedKappaWith
      & \tm{\cpCut{x}{\cpCase{y}{P}{Q}}{R}}
      & \Longrightarrow \;
      & \tm{\cpCase{y}{\cpCut{x}{P}{R}}{\cpCut{x}{Q}{R}}}
      \\
      \cpRedKappaTop
      & \tm{\cpCut{x}{\cpAbsurd{y}}{R}}
      & \Longrightarrow \;
      & \tm{\cpAbsurd{y}}
    \end{array}
  \]
  \begin{center}
    \begin{prooftree*}
      \AXC{$\reducesto{P}{P^\prime}$}
      \SYM{\cpRedGammaCut}
      \UIC{$\reducesto{\cpCut{x}{P}{Q}}{\cpCut{x}{P^\prime}{Q}}$}
    \end{prooftree*}
    \begin{prooftree*}
      \AXC{$\tm{P}\equiv\tm{Q}$}
      \AXC{$\reducesto{Q}{Q^\prime}$}
      \AXC{$\tm{Q^\prime}\equiv\tm{P^\prime}$}
      \SYM{\cpRedGammaEquiv}
      \TIC{$\reducesto{P}{P^\prime}$}
    \end{prooftree*}
  \end{center}
\end{definition}

\begin{definition}[Types]\label{def:cp-types}
  \[
    \begin{array}{rclrcl}
      \ty{A}, \ty{B}, \ty{C}
           :=& \ty{A \tens B} &\text{pair of independent processes}
      &  \mid& \ty{\one}      &\text{unit for} \; {\tens}
      \\ \mid& \ty{A \parr B} &\text{pair of interdependent processes}
      &  \mid& \ty{\bot}      &\text{unit for} \; {\parr}
      \\ \mid& \ty{A \plus B} &\text{internal choice}
      &  \mid& \ty{\nil}      &\text{unit for} \; {\plus}
      \\ \mid& \ty{A \with B} &\text{external choice}
      &  \mid& \ty{\top}      &\text{unit for} \; {\with}
    \end{array}
  \]
\end{definition}

\begin{figure*}[!htb]
  Structural Rules.
  \begin{center} \cpInfAx     \cpInfCut      \end{center}

  Logical Rules.
  \begin{center} \cpInfTens   \cpInfParr     \end{center}
  \begin{center} \cpInfOne    \cpInfBot      \end{center}
  \begin{center} \cpInfPlus1  \cpInfPlus2    \end{center}
  \begin{center} \cpInfWith                  \end{center}
  \begin{center} \cpInfNil    \cpInfTop      \end{center}

  \caption{Classical Processes (\cp)}
  \label{fig:cp}
\end{figure*}

\begin{lemma}[Preservation for $\equiv$]\label{lem:cp-preservation-equiv}
  If $\tm{P}\equiv\tm{Q}$, then $\seq[P]{\Gamma}$ iff $\seq[Q]{\Gamma}$.
\end{lemma}
\begin{proof}
  By induction on the derivation of $\tm{P}\equiv\tm{Q}$.
\end{proof}

\begin{theorem}[Preservation]\label{thm:cp-preservation}
  If $\seq[P]{\Gamma}$ and $\reducesto{P}{Q}$, then $\seq[Q]{\Gamma}$.
\end{theorem}
\begin{proof}
  By induction on the derivation of $\reducesto{P}{Q}$.
\end{proof}

\begin{theorem}[Progress]\label{thm:cp-progress}
  If $\seq[P]{\Gamma}$, then there exists a $\tm{Q}$ such that
  $\tm{P}\Longrightarrow^\star\tm{Q}$ and $\tm{Q}$ is not a cut.
\end{theorem}
\begin{proof}
  By induction on the derivation of $\seq[P]{\Gamma}$.
  If the last rule is \textsc{Cut}, there are four cases:
  \begin{enumerate*}[label={\alph*)}]
  \item
    if either side of the cut is an axiom, we apply \cpRedAxCut1;
  \item
    if either side of the cut is itself a cut, we recursively eliminate the cut;
  \item
    if both sides are logical rules acting on the cut formula, we apply
    one of the $\beta$-rules;
  \item
    otherwise, at least one side is a logical rule acting on a formula other
    than the cut formula, in which case we apply one of the $\kappa$-rules.
  \end{enumerate*}
\end{proof}


\section{Hypersequent Classical Processes}

\begin{definition}[Terms]\label{def:hcp-terms}
  \[
    \begin{array}{rllrll}
      \tm{P}, \tm{Q}, \tm{R}
           :=& \tm{\cpLink{x}{y}}         &\text{link}
      &  \mid& \tm{\piHalt}               &\text{terminated process}
      \\ \mid& \tm{\piNew{x}{P}}          &\text{name restriction, ``cut''}
      &  \mid& \tm{( \piPar{P}{Q} )}      &\text{parallel composition, ``mix''}
      \\ \mid& \tm{\piBoundSend{x}{y}{P}} &\text{``output''}
      &  \mid& \tm{\piRecv{x}{y}{P}}      &\text{``input''}
      \\ \mid& \tm{\piBoundSend{x}{}{P}}  &\text{``halt''}
      &  \mid& \tm{\cpWait{x}{}{P}}       &\text{wait}
      \\ \mid& \tm{\cpInl{x}{P}}          &\text{select left choice}
      &  \mid& \tm{\cpInr{x}{P}}          &\text{select right choice}
      \\ \mid& \tm{\cpCase{x}{P}{Q}}      &\text{offer binary choice}
      &  \mid& \tm{\cpAbsurd{x}}          &\text{offer nullary choice}
    \end{array}
  \]
\end{definition}

\begin{definition}[Structural congruence]\label{def:hcp-equiv}
  The structural congruence $\equiv$ is the congruence closure over terms which
  satisfies the following additional axioms:
  \[
    \setlength{\arraycolsep}{3pt}
    \begin{array}{llcllllcll}
        \cpEquivLinkComm
      & \tm{\cpLink{x}{y}}
      & \equiv
      & \tm{\cpLink{y}{x}}
      &
      &
        \hccpEquivMixHalt1
      & \tm{\piPar{P}{\piHalt}}
      & \equiv
      & \tm{P}
      &
      \\
        \hccpEquivMixComm
      & \tm{\piPar{P}{Q}}
      & \equiv
      & \tm{\piPar{Q}{P}}
      &
      &
        \hccpEquivMixAss1
      & \tm{\piPar{P}{( \piPar{Q}{R} )}}
      & \equiv
      & \tm{\piPar{( \piPar{P}{Q} )}{R}}
      &
      \\
        \hccpEquivNewComm
      & \tm{\piNew{x}{\piNew{y}{P}}}
      & \equiv
      & \tm{\piNew{y}{\piNew{x}{P}}}
      &
      &
        \hccpEquivScopeExt1
      & \tm{\piNew{x}{( \piPar{P}{Q} )}}
      & \equiv
      & \tm{\piPar{P}{\piNew{x}{Q}}}
      & \text{if }\notFreeIn{x}{P} 
    \end{array}
  \]
\end{definition}

\begin{definition}[Reduction]\label{def:hcp-reduction}
  A reduction $\reducesto{P}{Q}$ denotes that the process $\tm{P}$ can reduce
  to the process $\tm{Q}$ in a single step.
  The relation $\Longrightarrow^\star$ is the reflexive, transitive closure of
  $\Longrightarrow$.
  Reductions can only be constructed as follows:
  \[
    \begin{array}{llcll}
      \hccpRedAxCut1
      & \tm{\cpCut{x}{\cpLink{w}{x}}{P}}
      & \Longrightarrow
      & \tm{\cpSub{w}{x}{P}} 
      \\
      \hccpRedBetaTensParr
      & \tm{\cpCut{x}{\piBoundSend{x}{y}{P}}{\piRecv{x}{z}{R}}}
      & \Longrightarrow
      & \tm{\piNew{x}{\piNew{y}{(\piPar{P}{\cpSub{y}{z}{R}})}}}
      \\
      \hccpRedBetaOneBot
      & \tm{\cpCut{x}{\piBoundSend{x}{}{P}}{\piRecv{x}{}{P}}}
      & \Longrightarrow
      & \tm{\piPar{P}{Q}}
      \\
      \hccpRedBetaPlusWith1
      & \tm{\cpCut{x}{\cpInl{x}{P}}{\cpCase{x}{Q}{R}}}
      & \Longrightarrow
      & \tm{\cpCut{x}{P}{Q}}
      \\
      \hccpRedBetaPlusWith2
      & \tm{\cpCut{x}{\cpInr{x}{P}}{\cpCase{x}{Q}{R}}}
      & \Longrightarrow
      & \tm{\cpCut{x}{P}{R}}
      \\
      \hccpRedKappaNuTens
      & \tm{\piNew{x}{\piBoundSend{y}{z}{P}}}
      & \Longrightarrow
      & \tm{\piBoundSend{y}{z}{\piNew{x}{P}}}
      \\
      \hccpRedKappaNuParr
      & \tm{\piNew{x}{\piRecv{y}{z}{P}}}
      & \Longrightarrow
      & \tm{\piRecv{y}{z}{\piNew{x}{P}}}
      \\
      \hccpRedKappaNuOne
      & \tm{\piNew{x}{\piBoundSend{y}{}{P}}}
      & \Longrightarrow
      & \tm{\piBoundSend{y}{}{\piNew{x}{P}}}
      \\
      \hccpRedKappaNuBot
      & \tm{\piNew{x}{\piRecv{y}{}{P}}}
      & \Longrightarrow
      & \tm{\piRecv{y}{}{\piNew{x}{P}}}
      \\
      \hccpRedKappaNuPlus1
      & \tm{\piNew{x}{\cpInl{y}{P}}}
      & \Longrightarrow
      & \tm{\cpInl{y}{\piNew{x}{P}}}
      \\
      \hccpRedKappaNuPlus2
      & \tm{\piNew{x}{\cpInr{y}{P}}}
      & \Longrightarrow
      & \tm{\cpInr{y}{\piNew{x}{P}}}
      \\
      \hccpRedKappaNuWith
      & \tm{\piNew{x}{\cpCase{y}{P}{Q}}}
      & \Longrightarrow
      & \tm{\cpCase{y}{\piNew{x}{P}}{\piNew{x}{Q}}}
      \\
      \hccpRedKappaNuTop
      & \tm{\piNew{x}{\cpAbsurd{y}}}
      & \Longrightarrow
      & \tm{\cpAbsurd{y}}
      \\
      \hccpRedKappaMixTens
      & \tm{(\piPar{\piBoundSend{y}{z}{P}}{R})}
      & \Longrightarrow
      & \tm{\piBoundSend{y}{z}{(\piPar{P}{R})}}
      \\
      \hccpRedKappaMixParr
      & \tm{(\piPar{\piRecv{y}{z}{P}}{R})}
      & \Longrightarrow
      & \tm{\piRecv{y}{z}{(\piPar{P}{R})}}
      \\
      \hccpRedKappaMixOne
      & \tm{(\piPar{\piBoundSend{y}{}{P}}{R})}
      & \Longrightarrow
      & \tm{\piBoundSend{y}{}{(\piPar{P}{R})}}
      \\
      \hccpRedKappaMixBot
      & \tm{(\piPar{\piRecv{y}{}{P}}{R})}
      & \Longrightarrow
      & \tm{\piRecv{y}{}{(\piPar{P}{R})}}
      \\
      \hccpRedKappaMixPlus1
      & \tm{(\piPar{\cpInl{y}{P}}{R})}
      & \Longrightarrow
      & \tm{\cpInl{y}{(\piPar{P}{R})}}
      \\
      \hccpRedKappaMixPlus2
      & \tm{(\piPar{\cpInr{y}{P}}{R})}
      & \Longrightarrow
      & \tm{\cpInr{y}{(\piPar{P}{R})}}
      \\
      \hccpRedKappaMixWith
      & \tm{(\piPar{\cpCase{y}{P}{Q}}{R})}
      & \Longrightarrow
      & \tm{\cpCase{y}{(\piPar{P}{R})}{(\piPar{Q}{R})}}
      \\
      \hccpRedKappaMixTop
      & \tm{(\piPar{\cpAbsurd{y}}{R})}
      & \Longrightarrow
      & \tm{\cpAbsurd{y}}
    \end{array}
  \]
  \begin{center}
    \begin{prooftree*}
      \AXC{$\reducesto{P}{P^\prime}$}
      \SYM{\hccpRedGammaNew}
      \UIC{$\reducesto{\piNew{x}{P}}{\piNew{x}{P^\prime}}$}
    \end{prooftree*}
    \begin{prooftree*}
      \AXC{$\reducesto{P}{P^\prime}$}
      \SYM{\hccpRedGammaMix}
      \UIC{$\reducesto{\piPar{P}{Q}}{\piPar{P^\prime}{Q}}$}
    \end{prooftree*}
    \begin{prooftree*}
      \AXC{$\tm{P}\equiv\tm{Q}$}
      \AXC{$\reducesto{Q}{Q^\prime}$}
      \AXC{$\tm{Q^\prime}\equiv\tm{P^\prime}$}
      \SYM{\hccpRedGammaEquiv}
      \TIC{$\reducesto{P}{P^\prime}$}
    \end{prooftree*}
  \end{center}
\end{definition}

\begin{figure*}[!htb]
  Structural Rules.
  \begin{center} \hccpInfAx        \hccpInfCycle \end{center}
  \begin{center} \hccpInfMix       \hccpInfHalt  \end{center}

  Logical Rules.
  \begin{center} \hccpInfBoundTens \hccpInfParr  \end{center}
  \begin{center} \hccpInfOne       \hccpInfBot   \end{center}
  \begin{center} \hccpInfPlus1     \hccpInfPlus2 \end{center}
  \begin{center} \hccpInfWith                    \end{center}
  \begin{center} \hccpInfNil       \hccpInfTop   \end{center}

  \centering
  (Where each logical rule has the side condition that $\tm{x} \not\in
  \ty{\mathcal{G}}$.)

  \caption{Hypersequent Classical Processes (\hcp)}
  \label{fig:hccp}
\end{figure*}

\begin{lemma}[Preservation for $\equiv$]\label{lem:hcp-preservation-equiv}
  If $\tm{P}\equiv\tm{Q}$, then $\seq[P]{\mathcal{G}}$ iff $\seq[Q]{\Gamma}$.
\end{lemma}
\begin{proof}
  By induction on the derivation of $\tm{P}\equiv\tm{Q}$.
\end{proof}

\begin{theorem}[Preservation]\label{thm:hcp-preservation}
  If $\seq[P]{\mathcal{G}}$ and $\reducesto{P}{Q}$, then $\seq[Q]{\Gamma}$.
\end{theorem}
\begin{proof}
  By induction on the derivation of $\reducesto{P}{Q}$.
\end{proof}

\begin{theorem}[Progress]\label{thm:hcp-progress}
  If $\seq[P]{\mathcal{G}}$, then there exists a $\tm{Q}$ such that
  $\tm{P}\Longrightarrow^\star\tm{Q}$ and $\tm{Q}$ is not a cut or a mix.
\end{theorem}
\begin{proof}
  By induction on the derivation of $\seq[P]{\mathcal{G}}$.
  If the last rule is a cut, there are three cases:
  \begin{enumerate*}[label={\alph*)}]
  \item
    if the rule under the cut is the corresponding mix, we eliminate both as in
    \cref{thm:cp-progress};
  \item
    if the rule under the cut is an unrelated mix, we rewrite by
    \hccpEquivScopeExt{}, and recursively eliminate the cut; 
  \item
    if the rule under the cut is a logical rule, we apply one of the
    $\kappa\nu$-rules.
  \end{enumerate*}
  If the last rule is mix, there are two cases:
  \begin{enumerate*}[label={\alph*)}]
  \item
    if the rule under the mix is a cut or another mix, we recursively eliminate it;
  \item
    if the rule under the mix is a logical rule, we apply one of the
    $\kappa{\ppar}$-rules. 
  \end{enumerate*}
\end{proof}

\section{Relation between \cp and \hcp}

We define a translation from terms in \cp to terms in \hcp which breaks down the term constructs in \cp into their more atomic constructs in \hcp:
\begin{definition}\label{def:cp2hcp-terms}
  \[
    \begin{array}{lcllcl}
         \tm{\mtf{\cpLink{x}{y}}}
      &  := & \tm{\cpLink{x}{y}}
      &  \tm{\mtf{\cpCut{x}{P}{Q}}}
      &  := & \tm{\piNew{x}{(\piPar{\mtf{P}}{\mtf{Q}})}}
      \\ \tm{\mtf{\cpSend{x}{y}{P}{Q}}}
      &  := & \tm{\piBoundSend{x}{y}{(\piPar{\mtf{P}}{\mtf{Q}})}}
      &  \tm{\mtf{\cpRecv{x}{y}{P}}}
      &  := & \tm{\piRecv{x}{y}{\mtf{P}}}
      \\ \tm{\mtf{\cpHalt{x}}}
      &  := & \tm{\piBoundSend{x}{}{\piHalt}}
      &  \tm{\mtf{\cpWait{x}{P}}}
      &  := & \tm{\piRecv{x}{}{\mtf{P}}}
      \\ \tm{\mtf{\cpInl{x}{P}}}
      &  := & \tm{\cpInl{x}{\mtf{P}}}
      &  \tm{\mtf{\cpInr{x}{P}}}
      &  := & \tm{\cpInr{x}{\mtf{P}}}
      \\ \tm{\mtf{\cpCase{x}{P}{Q}}}
      &  := & \tm{\cpCase{x}{\mtf{P}}{\mtf{Q}}}
      &  \tm{\mtf{\cpAbsurd{x}}}
      &  := & \tm{\cpAbsurd{x}}
    \end{array}
  \]
\end{definition}

\begin{theorem}\label{thm:cp2hcp-typing}
  If $\seq[P]{\Gamma}$ in \cp, then $\seq[\mtf{P}]{\Gamma}$ in \hcp.
\end{theorem}
\begin{proof}
  By induction on the derivation of $\seq[P]{\Gamma}$.
    \begin{itemize}
  \item 
    Case \textsc{Cut}. We rewrite to:
    \begin{gather*}
      \begin{array}{lcl}
        \AXC{$\seq[P]{\Gamma, \tmty{x}{A}}$}
        \AXC{$\seq[Q]{\Delta, \tmty{x}{A^\bot}}$}
        \NOM{Cut}
        \BIC{$\seq[\cpCut{x}{P}{Q}]{\Gamma, \Delta}$}
        \DisplayProof
        & \Rightarrow
        & \AXC{$\seq[\mtf{P}]{\Gamma, \tmty{x}{A}}$}
          \AXC{$\seq[\mtf{Q}]{\Delta, \tmty{x}{A^\bot}}$}
          \NOM{H-Mix} 
          \BIC{$\seq[\piPar{\mtf{P}}{\mtf{Q}}]{
          \Gamma, \tmty{x}{A} \hsep \Delta, \tmty{x}{A^\bot}}$}
          \NOM{H-Cut}
          \UIC{$\seq[\piNew{x}{(\piPar{\mtf{P}}{\mtf{Q}})}]{
          \Gamma, \Delta}$}
          \DisplayProof
      \end{array}
    \end{gather*}
  \item
    Case $(\tens)$. We rewrite as follows:
    \begin{gather*}
      \begin{array}{lcl}
        \AXC{$\seq[P]{\Gamma, \tmty{y}{A}}$}
        \AXC{$\seq[Q]{\Delta, \tmty{x}{B}}$}
        \SYM{\tens}
        \BIC{$\seq[\cpSend{x}{y}{P}{Q}]{\Gamma, \Delta, \tmty{x}{A \tens B}}$}
        \DisplayProof
        & \Rightarrow
        & \AXC{$\seq[\mtf{P}]{\Gamma, \tmty{y}{A}}$}
          \AXC{$\seq[\mtf{Q}]{\Delta, \tmty{x}{B}}$}
          \NOM{H-Mix}
          \BIC{$\seq[\piPar{\mtf{P}}{\mtf{Q}}]{
          \Gamma, \tmty{y}{A} \hsep \Delta, \tmty{x}{B}}$}
          \SYM{\tens}
          \UIC{$\seq[\piBoundSend{x}{y}{(\piPar{\mtf{P}}{\mtf{Q}})}]{
          \Gamma, \Delta, \tmty{x}{A \tens B}}$}
          \DisplayProof
      \end{array}
    \end{gather*}
  \item
    Case $(\one)$. We rewrite as follows:
    \begin{flalign*}
      \begin{array}{lcl}
        \AXC{}\SYM{\one}
        \UIC{$\seq[\cpHalt{x}]{\tmty{x}{\one}}$}
        \DisplayProof
        & \Rightarrow
        & \AXC{}
          \NOM{H-Halt}
          \UIC{$\seq[\piHalt]{\emptyhypercontext}$}
          \SYM{\one}
          \UIC{$\seq[\piBoundSend{x}{}{\piHalt}]{\tmty{x}{\one}}$}
          \DisplayProof
      \end{array}      
    \end{flalign*}
  \end{itemize}
  The other cases are trivial.
\end{proof}

\begin{theorem}\label{thm:cp2hcp-equiv}
  $\tm{P}\equiv\tm{Q}$ in \cp iff $\tm{\mtf{P}}\equiv\tm{\mtf{Q}}$ in \hcp.
\end{theorem}
\begin{proof}
  By induction on the derivation of $\tm{P}\equiv\tm{Q}$.
% \begin{itemize}
% \item
%   Case \cpEquivCutComm.
%   \begin{gather*}
%   \begin{array}{lcl}
%     \tm{\piNew{x}{(\piPar{\mtf{P}}{\mtf{Q}})}}
%     & \equiv & \text{by \hccpEquivMixComm}
%     \\
%     \tm{\piNew{x}{(\piPar{\mtf{Q}}{\mtf{P}})}}
%   \end{array}
%   \end{gather*}
% \item
%   Case \cpEquivCutAss1.
%   \begin{gather*}
%   \begin{array}{lcl}
%     \tm{\piNew{x}{(\piPar{\mtf{P}}{\piNew{y}{(\piPar{\mtf{Q}}{\mtf{R}})}})}}
%     & \equiv & \text{%
%                by \hccpEquivNewComm, \hccpEquivMixAss1, \hccpEquivMixComm,
%                and \hccpEquivScopeExt{}}
%     \\
%     \tm{\piNew{y}{(\piPar{\piNew{x}{(\piPar{\mtf{P}}{\mtf{Q}})}}{\mtf{R}})}}
%   \end{array}
%   \end{gather*}
% \end{itemize}
% The other cases are trivial.
\end{proof}

\begin{theorem}\label{thm:cp2hcp-reduction}
  If $\reducesto{P}{Q}$ in \cp, then $\reducesto{\mtf{P}}{\mtf{Q}}$ in \hcp.
\end{theorem}
\begin{proof}
  By induction on the the derivation of $\reducesto{P}{Q}$.
% \begin{itemize}
% \item
%   Case \cpRedBetaTensParr.
%   \begin{gather*}
%   \begin{array}{lcl}
%     \tm{\piNew{x}{(\piPar{\piBoundSend{x}{y}{(\piPar{P}{Q})}}{\piRecv{x}{z}{R}})}}
%     & \Longrightarrow & \text{by \hccpRedBetaTensParr}
%     \\
%     \tm{\piNew{x}{\piNew{y}{(\piPar{(\piPar{P}{Q})}{\cpSub{y}{z}{R}})}}}
%     & \equiv & \text{%
%                by \hccpEquivNewComm, \hccpEquivMixAss1, and \hccpEquivScopeExt1}
%     \\
%     \tm{\piNew{y}{(\piPar{P}{\piNew{x}{(\piPar{Q}{\cpSub{y}{z}{R}})}})}}
%   \end{array}
%   \end{gather*}
% \item
%   Case \cpRedBetaOneBot.
%   \begin{gather*}
%   \begin{array}{lcl}
%     \tm{\piNew{x}{(\piPar{\piBoundSend{x}{}{\piHalt}}{\piRecv{x}{}{\mtf{Q}}})}}
%     & \Longrightarrow & \text{by \hccpRedBetaOneBot}
%     \\
%     \tm{(\piPar{\piHalt}{\mtf{Q}})}
%     & \equiv & \text{by \hccpEquivMixHalt1}
%     \\
%     \tm{\mtf{Q}}
%   \end{array}
%   \end{gather*}
% \end{itemize}
% The other cases are trivial.
\end{proof}

\begin{theorem}\label{hcp2cp-reduction}
  If $\reducesto{\mtf{P}}{R}$ in \hcp, then there is a $\tm{Q}$ such that
  $\reducesto{P}{Q}$ in \cp and $\tm{R}\Longrightarrow^\star\tm{\mtf{Q}}$ in \hcp.
\end{theorem}
\begin{proof}
  By induction on the derivation of $\reducesto{\mtf{P}}{R}$.
  The cases for \hccpRedAxCut1 and the $\beta$-rules are trivial.
  For the $\kappa\nu$-rules, we rewrite by the appropriate $\kappa{\ppar}$ rule,
  and vice versa.
\end{proof}

\begin{definition}\label{def:hcp-gk}
  The relation $\tm{P}\equiv_{\gamma\kappa}\tm{Q}$ is the congruence closure of
  the $\gamma$- and $\kappa$-rules for \hcp (\cref{def:hcp-reduction}).
\end{definition}

\begin{lemma}[Disentangle]\label{lem:hcp-disentangle}
  If $\seq[P]{\Gamma_1 \hsep \dots \hsep \Gamma_n}$ in \hcp,
  then there exist $\seq[P_1]{\Gamma_1}, \dots, \seq[P_n]{\Gamma_n}$ in \cp,
  such that
  $\tm{P}\equiv_{\gamma\kappa}\tm{(\mtf{P_1}\ppar\dots\ppar\mtf{P_n})}$.
\end{lemma}
\begin{proof}  
  We repeatedly apply the $\kappa{\ppar}$-rules to move the mixes upwards.
  There are three cases:
  \begin{enumerate*}[label={\alph*)}]
  \item
    if a mix gets stuck under a cut, it forms a \cp cut;
  \item
    if a mix gets stuck under a $(\tens)$, it forms a \cp $(\tens)$;
  \item
    otherwise, it moves all the way to the top.
  \end{enumerate*}
  Since the only way to continue after a $(\one)$ is by using a mix, all
  applications of $(\one)$ are now followed by an application of
  \textsc{H-Halt}, forming a \cp $(\one)$.
\end{proof}

We can interpret environments as types by collapsing them using a series of
pars.
\begin{definition}\label{def:bigparr}
  \begin{gather*}
  \begin{array}{lcl}
    \ty{\bigparr(\tmty{x_1}{A_1} , \dots , \tmty{x_n}{A_n})}
    & = & \ty{A_1 \parr \dots \parr A_n}
  \end{array}
  \end{gather*}
\end{definition}

\begin{lemma}\label{lem:cp-bigparr}
  If $\seq{\Gamma}$ in \cp, then $\seq{\bigparr\Gamma}$ in \cp.
\end{lemma}
\begin{proof}
  By induction on the structure of the environment $\Gamma$.
  \begin{itemize}
  \item
    If $\ty{\Gamma} = \ty{A}$, then the statement is trivially true.
  \item
    If $\ty{\Gamma} = \ty{A, B, \Gamma'}$,
    then we apply $(\parr)$ to get $\seq{A \parr B, \Gamma'}$,\\
    and apply the induction hypothesis.
  \end{itemize}
\end{proof}

We can interpret hyper-environments as types by collapsing them using a series
of tensors. In the case of the empty hyper-environment
$\ty{\emptyhypercontext}$, we interpret this as the unit of tensor.
\begin{definition}\label{def:bigtens}
  \begin{gather*}
  \begin{array}{lcl}
    \ty{\bigtens(\emptyhypercontext)}
    & = & \ty{\one}
    \\
    \ty{\bigtens(\Gamma_1 \hsep \dots \hsep \Gamma_n)}
    & = & \ty{\bigparr\Gamma_1 \tens \dots \tens \bigparr\Gamma_n}
  \end{array}
  \end{gather*}
\end{definition}

\begin{theorem}\label{thm:hcp2cp-bigtens}
  If $\seq{\mathcal{G}}$ in \hcp, then $\seq{\bigtens\mathcal{G}}$ in \cp.
\end{theorem}
\begin{proof}
  By case analysis on the structure of the hyper-environment $\ty{\mathcal{G}}$.
  \begin{itemize}
  \item
    If $\ty{\mathcal{G}} = \ty{\emptyhypercontext}$, we apply $(\one)$.
  \item
    If $\ty{\mathcal{G}} = \ty{\Gamma_1 \hsep \dots \hsep \Gamma_n}$,
    we apply \cref{lem:hcp-disentangle} to obtain proofs of $\seq{\Gamma_1}, \dots,
    \seq{\Gamma_n}$ in \cp, then we apply \cref{lem:cp-bigparr} to each of
    those proofs to obtain proofs of $\seq{\bigparr\Gamma_1}, \dots,
    \seq{\bigparr\Gamma_n}$, and join them using $(\tens)$ to obtain a single
    proof of $\seq{\bigtens\mathcal{G}}$ in \cp.
  \end{itemize}
\end{proof}

\section{Related Work}

Since its inception, linear logic was described as the logic of concurrency \citep{girard1987}. Correspondences between the proof theory of linear logic and variants of the $\pi$-calculus emerged soon afterwards \citep{abramsky1994,bellin1994}, by interpreting linear logic propositions as types for channels. Later, linearity inspired also the seminal theories of linear types for the $\pi$-calculus \cite{kobayashi1999} and session types \cite{honda1998}. Even though the two theories do not use exactly linear logic, the work by \citet{dardha2017} shows that the link is still strong enough that session types can be encoded into linear types.

It took more than ten years for a formal correspondence between linear logic and (a variant of) session types to emerge, with the seminal paper by \citet{caires2010}. This then inspired the development of Classical Processes (CP) by \citet{wadler2014}. %, which we have already discussed in the Introduction. %\todo{mention this}

The idea of extending linear logic to hypersequents for typing processes is not new. Specifically, in \cite{carbone18}, the multiplicative-additive fragment of Intuitionistic Linear Logic is extended with hypersequents to type choreographies (global descriptions of process communications). Differently, HCP is based on CLL, uses hypersequents to type processes.
%, and deals also with exponentials and polymorphism. 
The major difference is that the rules for manipulating hypersequents are different w.r.t.~\cite{carbone18}. In particular, hypersequents can be 
formed in \cite{carbone18} only when sequents share resources (\cf our \NOM{H-Mix}), and resource sharing is then explicitly tracked using an additional connection modality (which is not present in \hcp).

%As a consequence, the work in \cite{carbone18} does not support an LTS for the same reasons that we discussed for CP in the Introduction. Adding a connection modality to CT might be interesting for providing an LTS semantics to the choreographies studied in \cite{carbone18}.


\section{Conclusions}
\label{sec:conclusions}

%\bibliographystyle{eptcs}
\bibliographystyle{abbrvnat}
\bibliography{main}
\end{document}
%%% Local Variables:
%%% TeX-master: "main"
%%% End:
