%% Depends on: amsmath, stmaryrd, xspace, bussproofs, preamble-typing, preamble-pi

\providecommand{\piDILL}{\textpi DILL\xspace}
\providecommand{\cp}{CP\xspace}
\providecommand{\rcp}{RCP\xspace}

%% Legacy
\providecommand{\cpCutOld}[3]{\ensuremath{\nu #1.(\piPar{#2}{#3})}}

%% Terms
\providecommand{\cpLink}[2]{\ensuremath{#1{\leftrightarrow}#2}}
\providecommand{\cpCut}[3]{\ensuremath{\piNew{#1}({\piPar{#2}{#3}})}}
\providecommand{\cpSend}[4]{\ensuremath{#1[#2].(\piPar{#3}{#4})}}
\providecommand{\cpRecv}[3]{\ensuremath{#1(#2).#3}}
\providecommand{\cpWait}[2]{\ensuremath{#1().#2}}
\providecommand{\cpHalt}[1]{\ensuremath{#1[].0}}
\providecommand{\cpInl}[2]{\ensuremath{#1\triangleleft\texttt{inl}.#2}}
\providecommand{\cpInr}[2]{\ensuremath{#1\triangleleft\texttt{inr}.#2}}
\providecommand{\cpCase}[3]{\ensuremath{#1\triangleright\{\texttt{inl}:#2;\texttt{inr}:#3\}}}
\providecommand{\cpAbsurd}[1]{\ensuremath{#1\triangleright\{\}}}
\providecommand{\cpSub}[3]{\ensuremath{\piSub{#1}{#2}{#3}}}
\providecommand{\cpPlug}[2]{\ensuremath{{#1}[{#2}]}}

%% Types
\providecommand{\parr}{\mathbin{\bindnasrepma}}
\providecommand{\with}{\mathbin{\binampersand}}
\providecommand{\plus}{\ensuremath{\oplus}}
\providecommand{\tens}{\ensuremath{\otimes}}
\providecommand{\one}{\ensuremath{\mathbf{1}}}
\providecommand{\nil}{\ensuremath{\mathbf{0}}}
\providecommand{\limp}{\ensuremath{\multimap}}
\providecommand{\emptycontext}{\ensuremath{\,\cdot\,}}
\providecommand{\bigtens}{\ensuremath{\scalerel*{\tens}{\sum}}}
\providecommand{\bigparr}{\ensuremath{\scalerel*{\parr}{\sum}}}


%% Reduction rule names
\newcommand{\cpEquivLinkComm}{\ensuremath{(\cpLink{}{}\text{-sym})}\xspace}
\newcommand{\cpEquivCutComm}{\ensuremath{(\nu\text{-comm})}\xspace}
\newcommand{\cpEquivCutAssNoParen}[1]{\ensuremath{\nu\text{-assoc}\xspace}}
\newcommand{\cpEquivCutAss}[1]{\ensuremath{(\cpEquivCutAssNoParen{#1})}\xspace}
\newcommand{\cpRedAxCut}[1]{\ensuremath{(\cpLink{}{})}\xspace}
\newcommand{\cpRedBetaTensParr}{\ensuremath{(\beta{\tens}{\parr})}\xspace}
\newcommand{\cpRedBetaOneBot}{\ensuremath{(\beta{\one}{\bot})}\xspace}
\newcommand{\cpRedBetaPlusWith}[1]{\ensuremath{(\beta{\plus}{\with}_{#1})}\xspace}
\newcommand{\cpRedKappaTens}[1]{\ensuremath{(\kappa{\tens}_{#1})}\xspace}
\newcommand{\cpRedKappaParr}{\ensuremath{(\kappa{\parr})}\xspace}
\newcommand{\cpRedKappaBot}{\ensuremath{(\kappa{\bot})}\xspace}
\newcommand{\cpRedKappaPlus}[1]{\ensuremath{(\kappa{\plus}_{#1})}\xspace}
\newcommand{\cpRedKappaWith}{\ensuremath{(\kappa{\with})}\xspace}
\newcommand{\cpRedKappaTop}{\ensuremath{(\kappa{\top})}\xspace}
\newcommand{\cpRedGammaCut}{\ensuremath{(\gamma\nu)}\xspace}
\newcommand{\cpRedGammaEquiv}{\ensuremath{(\gamma{\equiv})}\xspace}

%% Structural rules
\providecommand{\cpInfAx}{%
  \begin{prooftree*}
    \AXC{$\vphantom{\seq[ Q ]{ \Delta, \tmty{y}{A^\bot} }}$}
    \NOM{Ax}
    \UIC{$\seq[ \cpLink{x}{y} ]{ \tmty{x}{A}, \tmty{y}{A^\bot} }$}
  \end{prooftree*}}
\providecommand{\cpInfCut}{%
  \begin{prooftree*}
    \AXC{$\seq[ P ]{ \Gamma, \tmty{x}{A} }$}
    \AXC{$\seq[ Q ]{ \Delta, \tmty{x}{A^\bot} }$}
    \NOM{Cut}
    \BIC{$\seq[ \cpCut{x}{P}{Q} ]{ \Gamma, \Delta }$}
  \end{prooftree*}}
\providecommand{\cpInfMix}{%
  \begin{prooftree*}
    \AXC{$\seq[ P ]{ \Gamma }$}
    \AXC{$\seq[ Q ]{ \Delta }$}
    \NOM{Mix}
    \BIC{$\seq[ \piPar{P}{Q} ]{ \Gamma , \Delta }$}
  \end{prooftree*}}
\providecommand{\cpInfCycle}{%
  \begin{prooftree*}
    \AXC{$\seq[ P ]{ \Gamma, \tmty{x}{A}, \tmty{y}{A^\bot}}$}
  \end{prooftree*}}
\providecommand{\cpInfHalt}{%
  \begin{prooftree*}
    \AXC{$\vphantom{\seq[ Q ]{ \Delta, \tmty{y}{A^\bot} }}$}
    \NOM{Halt}
    \UIC{$\seq[{ \piHalt }]{}$}
  \end{prooftree*}}

%% Logical rules
\providecommand{\cpInfTens}{%
  \begin{prooftree*}
    \AXC{$\seq[ P ]{ \Gamma , \tmty{y}{A} }$}
    \AXC{$\seq[ Q ]{ \Delta , \tmty{x}{B} }$}
    \SYM{(\tens)}
    \BIC{$\seq[ \cpSend{x}{y}{P}{Q} ]{ \Gamma , \Delta , \tmty{x}{A \tens B} }$}
  \end{prooftree*}}
\providecommand{\cpInfParr}{%
  \begin{prooftree*}
    \AXC{$\seq[ P ]{ \Gamma , \tmty{y}{A} , \tmty{x}{B} }$}
    \SYM{(\parr)}
    \UIC{$\seq[ \cpRecv{x}{y}{P} ]{ \Gamma , \tmty{x}{A \parr B} }$}
  \end{prooftree*}}
\providecommand{\cpInfOne}{%
  \begin{prooftree*}
    \AXC{$\vphantom{\seq[ P ]{ \Gamma }}$}
    \SYM{(\one)}
    \UIC{$\seq[ \cpHalt{x} ]{ \tmty{x}{\one} }$}
  \end{prooftree*}}
\providecommand{\cpInfBot}{%
  \begin{prooftree*}
    \AXC{$\seq[ P ]{ \Gamma }$}
    \SYM{(\bot)}
    \UIC{$\seq[ \cpWait{x}{P} ]{ \Gamma , \tmty{x}{\bot} }$}
  \end{prooftree*}}
\providecommand{\cpInfPlus}[1]{%
  \ifdim#1pt=1pt
  \begin{prooftree*}
    \AXC{$\seq[ P ]{ \Gamma , \tmty{x}{A} }$}
    \SYM{(\plus_1)}
    \UIC{$\seq[{ \cpInl{x}{P} }]{ \Gamma , \tmty{x}{A \plus B} }$}
  \end{prooftree*}
  \else%
  \ifdim#1pt=2pt
  \begin{prooftree*}
    \AXC{$\seq[ P ]{ \Gamma , \tmty{x}{B} }$}
    \SYM{(\plus_2)}
    \UIC{$\seq[ \cpInr{x}{P} ]{ \Gamma , \tmty{x}{A \plus B} }$}
  \end{prooftree*}
  \else%
  \fi%
  \fi%
}
\providecommand{\cpInfWith}{%
  \begin{prooftree*}
    \AXC{$\seq[ P ]{ \Gamma , \tmty{x}{A} }$}
    \AXC{$\seq[ Q ]{ \Gamma , \tmty{x}{B} }$}
    \SYM{(\with)}
    \BIC{$\seq[ \cpCase{x}{P}{Q} ]{ \Gamma , \tmty{x}{A \with B} }$}
  \end{prooftree*}}
\providecommand{\cpInfNil}{%
  (no rule for \ty{\nil})}
\providecommand{\cpInfTop}{%
  \begin{prooftree*}
    \AXC{}
    \SYM{(\top)}
    \UIC{$\seq[ \cpAbsurd{x} ]{ \Gamma, \tmty{x}{\top} }$}
  \end{prooftree*}}

%%% Local Variables:
%%% TeX-master: "main"
%%% End:
